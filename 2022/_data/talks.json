{
  "items": [
    {
      "id": "61df3543ef0a16083d127537",
      "title": "Progressive Delivery in the Kubernetes era",
      "languages": [
        "eng",
        "es"
      ],
      "abstract": "Production is the place where all applications should live. Even though you are using continuous integration and delivery, you might wonder every time you release a new version to production if it will work or there will be some breakage on the latest version, eventually making production unavailable to the customers. \n\nProgressive delivery is the next step after Continuous Delivery to test your application in production before it becomes fully available to all your user bases.\n\nEmbrace progressive delivery with techniques like the blue-green, canary release, shadowing traffic, or dark launches to validate the application in production using Kubernetes and tools like Istio, Prometheus, ArgoCD, or Argo Rollouts.\n\nCome to this session to learn progressive delivery in action using Kubernetes.",
      "type": "talk",
      "tags": [
        "kubernetes",
        "argocd",
        "argo rollouts"
      ],
      "level": "advanced",
      "speakers": [
        "5c4dc84af05c736fb61555d97670869511e52764"
      ]
    },
    {
      "id": "61e406409e44e3083e435f60",
      "title": "The hidden gems of distributed tracing",
      "languages": [
        "eng"
      ],
      "abstract": "When building distributed systems, we aim to get a macro view and zoom in when a particular component seems to be at fault for a failure. Luckily, distributed tracing captures the detailed execution of causally-related activities performed by the elements of a distributed system as it processes a given request.\nIf you wonder how different the execution of the requests from the system's expected behavior was, join my session to learn how to recognize trace patterns, determine the bottlenecks when a request is too slow, and deal with oversampling or traffic labeling in production.\n",
      "type": "talk",
      "tags": [
        "cloud",
        "distributed systems",
        "tracing",
        "practices"
      ],
      "level": "middle",
      "speakers": [
        "959143ffd6c954e5e544cdce71383429895e3679"
      ]
    },
    {
      "id": "61f1a0e0c4c4120b9d29afa0",
      "title": "Freedom Means That Kubernetes Needs To Disappear",
      "languages": [
        "eng"
      ],
      "abstract": "We are all moving towards service-based operations and self-sufficient teams. We are all trying to enable developers to be more autonomous. However, it is unrealistic to expect everyone to become an expert on everything, from infrastructure to Kubernetes and everything in between. So, we cannot shift left due to lack of expertise, but we also cannot continue being reactive to the needs of others. The only option left is to simplify services or even remove direct access to infrastructure and Kubernetes.\n\nWe might be able to accomplish those goals through Argo CD or Flux (GitOps), Crossplane (universal control plane), and KubeVela (OAM). By combining those, we can enable developers to manage everything yet still be in complete control of the aspects they care about. GitOps allows us to establish Git as the only point of interaction with the system. Crossplane Composites enable us to simplify developer experience when managing infrastructure. Finally, the Open Application Model (OAM) with KubeVela allows us to define applications instead of Kubernetes resources. If we combine those three types of tools and processes, we can enable operations to define the services used by developers to manage infrastructure and applications. We can do all that without anyone even knowing that there is Kubernetes behind all that.\n\nFor everyone to use Kubernetes, it needs to disappear.\n",
      "type": "talk",
      "tags": [
        "Cloud",
        "Kubernetes",
        "Crossplane",
        "OAM",
        "KubeVela"
      ],
      "level": "middle",
      "speakers": [
        "0ba89c51baf9f8542188bd750973e0767fbcaa68"
      ]
    },
    {
      "id": "61f1a32cc4c4120b9d29afa3",
      "title": "Live Diagramming of Knative Core Concepts",
      "languages": [
        "eng"
      ],
      "abstract": "Although Knative has been community-maintained since 2018, there has been buzz around the project lately because Google has recently submitted Knative to the CNCF for consideration as an incubating project.\n\nCool! But what is Knative, exactly?\n\nSimply put, Knative is a technology that streamlines and enhances the way that applications run on Kubernetes.\n\nThis talk is for people who are excited about this value proposition and want to dig deeper. How does it work? What components are at play? In what ways is running an app on Knative superior to running it directly on Kubernetes?\n\nInstead of presenting slides, Whitney will draw out the fundamental concepts of Knative, explaining how they work in simple, relatable terms. She will then drive deeper understanding by giving context to the main points with real-life, straightforward use cases. \n\nAttend this talk to gain a high-level understanding of Knative, its main components, and how it simplifies and improves the way that apps run on Kubernetes.",
      "type": "talk",
      "tags": [
        "Knative",
        "Kubernetes",
        "Cloud",
        "Eventing"
      ],
      "level": "beginner",
      "speakers": [
        "576aeba6a8ebcbe244cc16bd0f973593673cc530"
      ]
    },
    {
      "id": "61f1a45bc4c4120b9d29afa4",
      "title": "Dapr: Dinosaur or Developer's Dream?",
      "languages": [
        "eng"
      ],
      "abstract": "Dapr lets you abstract your distributed architecture from the underlying infrastructure that powers it. Forget about Kafka, RabbitMQ or any cloud-specific product: you're talking with a pub/sub broker. Let Dapr take care of how it works. Want to switch later? Sure, no problem!\n\nSo, is Dapr the new J2EE application server? How could it change the way we develop distributed solutions? Join me in this talk to find out if we're looking at a dinosaur in a fancy suit, or a developer's dream.",
      "type": "talk",
      "tags": [
        "distributed architecture",
        "cloud native"
      ],
      "level": "middle",
      "speakers": [
        "f33256b1512b570f58cde29c69166d0fab470334"
      ]
    },
    {
      "id": "61f1ba52c4c4120b9d29afa6",
      "title": "Java Next - From Amber to Loom, from Panama to Valhalla",
      "languages": [
        "eng"
      ],
      "abstract": "Java's four big projects are entering the home stretch: Amber and Panama have already incubated, previewed, and even finalized some features, Loom and Valhalla are on track to follow soon. Time to take a closer look at how...\n<ul>\n<li>Project Amber makes the language more expressive and ready for today's and tomorrow's problems</li>\n<li>Project Panama cuts through the isthmus separating Java from native code</li>\n<li>Project Loom enables hassle-free and efficient structured concurrency</li>\n<li>Project Valhalla mends the rift in Java's type system and improves performance</li>\n</ul>\nAfter this talk, you will know what to expect from Java in the next few years.",
      "type": "talk",
      "tags": [
        "Java",
        "Amber",
        "Panama",
        "Loom",
        "Valhalla"
      ],
      "level": "advanced",
      "speakers": [
        "78328a04b91142ff18f2a8885d6ec99391906a66"
      ]
    },
    {
      "id": "61fc3c314fc8140baaa031b5",
      "title": "Kubernetes Native Java",
      "languages": [
        "eng"
      ],
      "abstract": "Spring is all about helping developers get to production quickly and safely. These days, \"production\" is all but guaranteed to mean Kubernetes, and Spring has you covered. Join me, Spring Developer Advocate Josh Long (@starbuxman), and we'll look at how Spring Boot makes writing blisteringly fast, cloud-native, and scalable services more effortless than ever.\n\n",
      "type": "talk",
      "tags": [
        "spring",
        "graalvm",
        "docker",
        "kubernetes",
        "buildpacks"
      ],
      "level": "middle",
      "speakers": [
        "3803f8e428feb905178afd9025cfc53fb47a8abc"
      ]
    },
    {
      "id": "61fd70f54fc8140baaa031bc",
      "title": "REACTIVE A New Hope! Learn From a Performance History",
      "languages": [
        "eng"
      ],
      "abstract": "It is a time of developers complain about performance. Rebel developers, striking from a hidden base, have won their first victory against the evil blocking applications. In this session, attendees will learn about a real-world evolution to reactive; we will be covering tips and tricks of an experience in evolving a Banking Application; Through the session, you are going to get tips, tricks, pros, cons, and the reasons for being involved on move forward to non-blocking application and present sample code and explain the security concerns on this evolution. We will be using snippets code based on JAVA, JWT, JWS, Auth0, Spring Boot, Reactor and Webflux deployed on Cloud.",
      "type": "talk",
      "tags": [
        "Java",
        "Reactive",
        "Microservice",
        "Architecture"
      ],
      "level": "middle",
      "speakers": [
        "8096d60f578c4cc2c777f231d1dff6aa46f4457b"
      ]
    },
    {
      "id": "61fd71234fc8140baaa031bd",
      "title": "Going Reactive with Helidon!",
      "languages": [
        "eng"
      ],
      "abstract": "Helidon is a brave, small but powerful opensource framework for writing microservices. And if you need get the maximum performance – making your apps reactive is the currently the best way to do it! In this session we will dive deeper and see how to create extremely performant reactive microservices with Helidon “SE” flavour. We will explore its Reactive APIs, asynchronous DB access, and reactive Web-Client. Since Helidon has its own powerful Reactive Engine, we will learn how to get the most requests served in async operations and Messaging. We will also compare the performance with Loom, since Helidon supports it out of the box! Welcome to the Danger Zone!\n\n",
      "type": "talk",
      "tags": [
        "helidon",
        "microservices",
        "reactive",
        "loom"
      ],
      "level": "middle",
      "speakers": [
        "74479a1ccc69e03d3868de48e18a4d759165d326"
      ]
    },
    {
      "id": "61fd71544fc8140baaa031be",
      "title": "Event streaming applications with Kafka Streams, Spring Kafka and Actuator (live coding)",
      "languages": [
        "eng"
      ],
      "abstract": "We often make applications in which REST (HTTP) predominates, but is this a smart choice? Can't it be faster, or rather asynchronously and event based? Especially if you work with BIG DATA, Kafka is usually the better option.You get a whole platform where scalability, fault tolerance and replay-ability are very important (you don't want your message to be lost, and preferably you want to process it again if your system has been down).\n\nThere are three libraries we will discuss during live coding:\n- Spring Kafka, where we will create a consumer and producer and test them with test-containers (without starting a whole cluster yourself).\n\n- Kafka Streams, a perfect fit for functional programming! With the StreamsAPI we will cover the best and most used patterns like branching, joining, mapping and more. We will create a Topology (stream) where we will handle fraud detection.\n\n- Spring Actuator is a match when you want to monitor your stream of events, you already got a lot of metrics for free!\n\nAfter the session you can create your own application with consumers, producers and streams!",
      "type": "talk",
      "tags": [
        "Kafka Streams",
        "Big Data",
        "Java"
      ],
      "level": "middle",
      "speakers": [
        "98d92074e12051b600499049a3773caf3fc5dd60"
      ]
    },
    {
      "id": "61fd72704fc8140baaa031bf",
      "title": "Performance Testing Java Applications",
      "languages": [
        "eng"
      ],
      "abstract": "Every so often,  you’ll read a performance benchmark (of a Java or other application), with bold claims for how well X performs compared to Y. Testing the performance of your Java application is an artform rather than engineering, and is a minefield of misconceptions, misunderstanding, and misinformation. In this session, we will review the basics and give you concrete steps to build a robust performance testbed for your application. We will be looking at this from a real-world server-side application point of view, specifically for Java apps. We’ll review common problems and how to avoid them. We’ll cover these topics while building up a performance test and running it live:\n\n\n\nDefine your goals: SLA, latency, throughput, stability\nTest env vs. Production env for testing\nThe impact of GC on Java app performance\nTools for setting up, driving load, and getting perf test results\nTesting application infrastructure like Kafka, Spark and Cassandra\nOperating system settings, JVM settings, memory sizing, and CPU sizing\nAnalyzing perf test results and finding bottlenecks that are both apparent and not obvious",
      "type": "talk",
      "tags": [
        "java",
        "performance"
      ],
      "level": "advanced",
      "speakers": [
        "5c8cf21786cae4a337b4c305fe244359243ded67"
      ]
    },
    {
      "id": "61fd73e74fc8140baaa031c0",
      "title": "Why You Can’t Buy Cloud Native",
      "languages": [
        "eng"
      ],
      "abstract": "The virtual shelves are filled to bursting with cloud native technologies; containers, runtimes, CI pipelines, observability tools. The more an organisation buys, the more cloud native it is, right? And the more network communication an app involves, the more cloud native it is, right? Well, not so much. It turns out cloud native is about how you deliver software, not the tools you use. This talk explains these often-overlooked elements for cloud native success:\n- Figuring out what problem we’re trying to solve\n- Releasing\n- Testing, but not the way you’re used to",
      "type": "talk",
      "tags": [
        "cloud",
        "culture"
      ],
      "level": "middle",
      "speakers": [
        "16b53ff6547870b3f9c9ef9f5eb97b015ba88e8b"
      ]
    },
    {
      "id": "61fd74f14fc8140baaa031c1",
      "title": "Tales from a Java Developer moving to Go in the context of Kubernetes",
      "languages": [
        "eng",
        "es"
      ],
      "abstract": "In this presentation, Mauricio, a very passionate Java Developer, share his psychedelic findings from working in the Go ecosystem for the Knative OSS Project. This presentation focuses on the Go ecosystem instead of the difference between the Java and Go languages. Tools like dependency management, IDEs, frameworks and how to deal with large projects will be discussed. While Java is still big in my heart there are good lessons, frameworks and tools that we might want to bring to the Java ecosystem from the vibrant Go community. A special emphasis is made around Kubernetes related tools and why I think that Go in Kubernetes is miles ahead of Java.",
      "type": "talk",
      "tags": [
        "Cloud",
        "java",
        "go",
        "kubernetes",
        "tools",
        "frameworks"
      ],
      "level": "middle",
      "speakers": [
        "4b26a098aafaf6bc3d533389b61d3ef5ab01f5a3"
      ]
    }
  ]
}
