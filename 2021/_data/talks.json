{
  "items": [
    {
      "id": "60c112eb3be4300877923156",
      "title": "Kontinuous Integration and Delivery in Kubernetes",
      "languages": [
        "es"
      ],
      "abstract": "Kubernetes ha madurado suficiente hasta convertirse en la plataforma de orquestración por excelencia, sin embargo aún le falta una un elemento crucial. Y esto hace que Integración Continua y despliegue sean menos efectivas.\nEl mercado ofrece varias soluciones para resolverlo, pero el 99% fallan al no ser nativas para Kuberntes.\n\nEn esta sesión, Alex nos explicará Tekton, la solución nativa Kubernetes para definir y ejecutar tu CI/CD. La sessión explora las características de Tekton y ArgoCD; Cloud Native, Desacoplados y Declarativos.\nJunto a demos en vivo se mostrará como encajar las diferentes piezas de Tekton para hacer tus builds in-cluster, y ArgoCD para desplegar tus aplicaciones Kubernetes.",
      "type": "talk",
      "tags": [
        "kubernetes",
        "continuous delivery"
      ],
      "level": "middle",
      "speakers": [
        "1cf43210c8515585e52e4d2f6f2e5e0f582049d8"
      ]
    },
    {
      "id": "60c113223be4300877923157",
      "title": "Los desarrolladores no necesitan Kubernetes",
      "languages": [
        "es"
      ],
      "abstract": "Desde la aparición de Kubernetes, esperábamos que los desarrolladores lo adoptaran. Eso no sucedió y probablemente nunca sucederá. Los desarrolladores no necesitan Kubernetes. Necesitan escribir código y una forma sencilla de crear, probar e implementar sus aplicaciones. No es realista esperar que los desarrolladores pasen años aprendiendo Kubernetes. Por otro lado, los operadores y administradores de sistemas necesitan Kubernetes. Les brinda todo lo que necesitan para ejecutar sistemas a escala. No obstante, los operadores también deben capacitar a los desarrolladores para que implementen sus propias aplicaciones. Necesitan capacitar a los desarrolladores proporcionando servicios en lugar de realizar implementaciones reales. Entonces, tenemos necesidades en conflicto. Kubernetes es necesario para algunos y una carga para otros. ¿Podemos satisfacer a todos? ¿Podemos tener un sistema basado en Kubernetes pero fácil de operar? ¿Podemos hacer que Kubernetes desaparezca y se convierta en un detalle de implementación ejecutándose en segundo plano? Analicemos hacia dónde se dirige Kubernetes y cómo podría verse en el futuro.",
      "type": "talk",
      "tags": [
        "Kubernetes",
        "developers"
      ],
      "level": "middle",
      "speakers": [
        "0ba89c51baf9f8542188bd750973e0767fbcaa68"
      ]
    },
    {
      "id": "60c113d33be4300877923158",
      "title": "Event-driven and serverless with Spring Cloud and Spring Native",
      "languages": [
        "eng"
      ],
      "abstract": "Applications in a microservices architecture can communicate with each other in different ways. Adopting an event-driven paradigm based on asynchronous messaging provides services a way of communicating while reducing runtime coupling. Functions are a natural way of implementing event-driven business logic in terms of suppliers, processors, and consumers. Furthermore, when going serverless, we aim at executables with instant startup and efficiency. Enter Spring.\n\nSpring Cloud Function favors using the functional programming paradigm to implement your business logic and provides useful features to build data pipelines, including type conversion and function composition. Functions can be exposed through different options (like web endpoints or message channels), and adapters are available to run them on platforms like Knative, AWS Lambda, Azure Functions, and GCP Functions. Spring Cloud Stream integrates your functions with messaging systems like RabbitMQ and Kafka without requiring any change to your code. Finally, Spring Native lets you compile your applications as native executable using GraalVM and providing instant startup, instant peak performance, and reduced memory consumption. ",
      "type": "talk",
      "tags": [
        "Java",
        "Cloud",
        "Serverless",
        "Spring Boot",
        "GraalVM",
        "Spring Cloud"
      ],
      "level": "beginner",
      "speakers": [
        "19243e47c15a9592009ca961a856d0091d957ab8"
      ]
    },
    {
      "id": "60c114103be4300877923159",
      "title": "Helidon – a great MicroService framework for the cloud world!",
      "languages": [
        "eng"
      ],
      "abstract": "\nIn this talk, I will tell you about a wonderful opensource framework for writing microservices called Helidon. By using it, you can write truly tiny microservices with a minimum memory footprint and distribution size, and at the same time, with performance that is often several times higher, the of its competitors. With the help of Helidon, you can write both portable code, standardized by MicroProfile, as well as an absolutely pure reactive java code. CLI, wonderful tooling, full support for GraalVM, and at least Java version 11 will allow us to write the most productive microservices without any compromise!\n",
      "type": "talk",
      "tags": [
        "helidon",
        "microsercices",
        "cloud",
        "natice",
        "javaee",
        "microprofile"
      ],
      "level": "beginner",
      "speakers": [
        "67155bca8730b7491ee45017054743b97982f3fb"
      ]
    },
    {
      "id": "60c1144b3be430087792315a",
      "title": "Despliega en Kubernetes usando Dekorate",
      "languages": [
        "es"
      ],
      "abstract": "Dekorate ofrece un conjunto de herramientas para generar manifiestos Kubernetes y OpenShift mientras compilas tu aplicacion. Te hará la vida más fácil porque no tienes que manipular ningún tipo de fichero JSON o YAML. Puedes usar anotaciones Java, ficheros application.properties o combinar los dos para personalizar los manifiestos. En esta sesión te enseñaré cómo desplegar fácilmente microservicios en Kubernetes y Openshift usando Dekorate, ¡no te la pierdas!\n",
      "type": "talk",
      "tags": [
        "microservice",
        "kubernetes",
        "openshift",
        "cloud",
        "java",
        "deploy"
      ],
      "level": "middle",
      "speakers": [
        "9e90e9ceb9ba68f67332f4efc12576651ca448a3"
      ]
    },
    {
      "id": "60ca52a41fc64e0884ea9ea7",
      "title": "Kafka and Pulsar: a gentle comparison",
      "languages": [
        "eng",
        "es"
      ],
      "abstract": "Apache Kafka has been the go-to publish-subscribe (pub-sub) messaging system for a while. It offers functionality for a wide range of enterprise use cases, along with a large ecosystem of tools and a dedicated community. But lately, upstart Apache Pulsar has been gaining ground. Pulsar takes the best parts of Kafka and expands on them to solve problems that were out of scope of Kafka’s original design but which are lately coming to Kafka. In this session we'll cover the differences between them, how to choose one depending on your use case and the state of the art of both. If you have interest in messaging brokers and how they work under the hood, this session is for you.",
      "type": "talk",
      "tags": [
        "kafka",
        "pulsar",
        "cloud",
        "streaming",
        "events"
      ],
      "level": "middle",
      "speakers": [
        "2b14d512d954c54d2bce56f69c2a7e1b755bee2f"
      ]
    },
    {
      "id": "60ca55081fc64e0884ea9ea8",
      "title": "Preparándonos para un mundo multi-cloud / Getting ready for a multi-cloud world",
      "languages": [
        "eng",
        "es"
      ],
      "abstract": "Si eres un desarrollador Cloud Native tarde o temprano algún Product Manager te preguntara: \"Pero esto se puede instalar en AWS y en Azure y en GCP?\" Seguido por: \"Tenemos un cliente que quiere lo mismo pero On-Premises\". Esta charla se enfoca en herramientas que apuntan a simplificar el desarrollo, despliegue y mantenimiento de aplicaciones cloud native construyendo funcionalidad sobre las APIs de Kubernetes. Esta charla muestra un ejemplo que la audiencia puede instalar en sus propios clusters de cómo estas herramientas pueden usarse en conjunto. Los siguientes proyectos seran explicados y demostrados: Knative, Crossplane, Helm, Tekton y CloudEvents. \n===\nIf you are a developer building Cloud Native applications, sooner or later a Product Manager will ask you: \"Can we deploy our application on AWS, Azure and GCP?\" followed by: \"We have a very good customer that wants our application to run On-Premises\". This presentation focuses on tools that aim to simplify the development, deployment and maintenance by building abstraction layers on top of the Kubernetes API. This presentation shows an example that the audience can install in their own environments using the following tools: Knative, Crossplane, Helm, Tekton and CloudEvents. ",
      "type": "talk",
      "tags": [
        "kubernetes",
        "cloud",
        "multi-cloud",
        "API",
        "java"
      ],
      "level": "middle",
      "speakers": [
        "4b26a098aafaf6bc3d533389b61d3ef5ab01f5a3"
      ]
    },
    {
      "id": "60d0d9ad1fc64e0884ea9ee9",
      "title": "Techniques for maintainable Quarkus Applications",
      "languages": [
        "eng"
      ],
      "abstract": "Over time, different people will work on a distributed system to maintain its current behavior and adapt the solution to new use cases; all these team members should work productively. Join this session to find out some techniques to calm those noisy loggers, avoid memory leaks, or have better control over your endpoints' response time; all these crafted to effectively maintain your Quarkus baked microservices.",
      "type": "talk",
      "tags": [
        "Quarkus",
        "Java",
        "Development Practices"
      ],
      "level": "middle",
      "speakers": [
        "959143ffd6c954e5e544cdce71383429895e3679"
      ]
    }
  ]
}